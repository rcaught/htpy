{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#htpy-html-in-python","title":"htpy - HTML in Python","text":"<p>htpy is a library that makes writing HTML in plain Python fun and efficient, without a template language.</p> <p>Define HTML in Python:</p> <pre><code>from htpy import body, h1, head, html, li, title, ul\n\nmenu = [\"egg+bacon\", \"bacon+spam\", \"eggs+spam\"]\n\nprint(\n    html[\n        head[title[\"Today's menu\"]],\n        body[\n            h1[\"Menu\"],\n            ul(\".menu\")[(li[item] for item in menu)],\n        ],\n    ]\n)\n</code></pre> <p>And Get HTML:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Today's menu&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Menu&lt;/h1&gt;\n    &lt;ul class=\"menu\"&gt;\n      &lt;li&gt;egg+bacon&lt;/li&gt;\n      &lt;li&gt;bacon+spam&lt;/li&gt;\n      &lt;li&gt;eggs+spam&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"#motivation-for-this-project","title":"Motivation for This Project","text":"<p>At Personalkollen, where htpy was originally developed we often found ourselves hitting walls when using classic templates. htpy was created to improve the productiveness and experience of generating HTML from a Python backend.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Leverage static types: Use mypy or pyright to type check your code.</p> </li> <li> <p>Great debugging: Avoid cryptic stack traces from templates. Use your favorite Python debugger.</p> </li> <li> <p>Easy to extend: There is no special way to define template tags/filters. Just call regular functions.</p> </li> <li> <p>Works with existing Python web framework: Works great with Django, Flask or any other Python web framework!</p> </li> <li> <p>Works great with htmx: htpy makes for a great experience when writing server rendered partials/components.</p> </li> <li> <p>Create reusable components: Define components, snippets, complex layouts/pages as regular Python variables or functions.</p> </li> <li> <p>Familiar concepts from React: React helped make it popular writing HTML with a programming language. htpy uses a lot of similar constructs.</p> </li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>htpy generates HTML elements and attributes and provide a few helpers.</p> <p>htpy does not enforce any particular pattern or style to organize your pages, components and layouts. That does not mean that htpy cannot be used to build sophisticated web pages or applications.</p> <p>Rather the opposite: you are encouraged the leverage the power of Python to structure your project. Use modules, classes, functions, decorators, list comprehension, generators, conditionals, static typing and any other feature of Python to organize your components. This gives you a lot of power and makes htpy scale from a single small Flask project to bigger applications.</p> <p>Common patterns can give you some ideas that you can build upon yourself.</p>"},{"location":"#the-syntax","title":"The Syntax","text":"<p>Child elements are specified using the <code>[]</code> syntax. This may look strange at first but it has some nice benefits. This clearly separates attributes from child elements and makes the code more readable. It is implemented using the <code>__getitem__</code> method, just like lists or dicts.</p>"},{"location":"#installation","title":"Installation","text":"<p>htpy is available on PyPI. You may install the latest version using pip:</p> <pre><code>pip install htpy\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The full documentation is available at htpy.dev:</p> <ul> <li>Usage</li> <li>Common patterns</li> <li>Static typing</li> <li>Usage with Django</li> <li>Streaming of contents</li> <li>Convert HTML to htpy code</li> <li>FAQ</li> <li>References</li> <li>Changelog</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#24101-2024-10-24","title":"24.10.1 - 2024-10-24","text":"<ul> <li>Fix handling of Python keywords such as <code>&lt;del&gt;</code> in html2htpy. PR #61.</li> </ul>"},{"location":"changelog/#24100-2024-10-23","title":"24.10.0 - 2024-10-23","text":"<ul> <li>Implement <code>Element.__html__</code>. This avoids double escaping when passed to <code>markupsafe.escape</code> and Django's <code>django.utils.html.conditional_escape</code>. PR #65.</li> <li>Raise errors directly on invalid children. This avoids cryptic stack traces. PR #56.</li> <li>Raise TypeError rather than ValueError when invalid types are passed as attributes or children. PR #59.</li> </ul>"},{"location":"changelog/#2491-2024-09-09","title":"24.9.1 - 2024-09-09","text":"<ul> <li>Raise errors directly on invalid attributes. This avoids cryptic stack traces   for invalid attributes. Issue #49 PR #55.</li> </ul>"},{"location":"changelog/#2483-2024-08-28","title":"24.8.3 - 2024-08-28","text":"<ul> <li>Support passing htpy elements directly to Starlette responses. Document Starlette support. PR #50.</li> <li>Allow passing ints to attributes and children PR #52.</li> </ul>"},{"location":"changelog/#2482-2024-08-23","title":"24.8.2 - 2024-08-23","text":"<ul> <li>Added support for passing data between components via Context. See the Usage docs for more information. PR #48.</li> <li>Added Django template backend. The Django template backend allows you to integrate htpy components directly with Django. See the docs for more information. PR #37.</li> </ul>"},{"location":"changelog/#2481-2024-08-16","title":"24.8.1 - 2024-08-16","text":"<ul> <li>Added the <code>comment()</code> function to render HTML comments.  Documentation /  Issue  #42.</li> <li>Run tests on Python 3.13 RC (no changes were required, earlier versions  should work fine too). PR #45.</li> <li>Attributes that are not strings will now be rejected runtime. Attributes have  been typed as strings previously but this is now also enforced during runtime.  If you need to pass non-strings as attribute values, wrap them in str() calls.</li> </ul>"},{"location":"changelog/#2480-2024-08-03","title":"24.8.0 - 2024-08-03","text":"<ul> <li>Allow conditional rendering based on <code>bool</code>. PR #40.</li> </ul> <p>For previous versions and changes, please see the git commit history.</p>"},{"location":"common-patterns/","title":"Common Patterns","text":"<p>htpy itself is a library that does not impose any particular structure for your code. You have the full power of Python functions, classes and modules at your disposal.</p> <p>General programming practices on how to structure modules, functions and classes apply to HTML generation with htpy.</p> <p>This page describes common scenarios and patterns that may help you structure your own project in a good way.</p>"},{"location":"common-patterns/#filemodule-structure","title":"File/Module Structure","text":"<p>It is generally a good idea to keep your HTML pages/components separate from HTTP request handling and \"business logic\".</p> <p>In Django, this means that the view function should not directly generate the HTML.</p> <p>Using a file named <code>components.py</code> can be a good idea. If you have many components, you may create a <code>components</code> package instead.</p> <p>Your component functions can accept arbitrary arguments with the required data. It is a good idea to only use keyword arguments (put a <code>*</code> on the left of the argument list to force keyword arguments):</p> views.py<pre><code>from django.http import HttpRequest, HttpResponse\n\nfrom .components import greeting_page\n\ndef greeting(request: HttpRequest) -&gt; HttpResponse:\n    return HttpResponse(greeting_page(\n        name=request.GET.get(\"name\", \"anonymous\"),\n    ))\n</code></pre> components.py<pre><code>from htpy import html, body, h1\n\ndef greeting_page(*, name: str) -&gt; Element:\n    return html[body[h1[f\"hi {name}!\"]]]\n</code></pre>"},{"location":"common-patterns/#using-a-base-layout","title":"Using a Base Layout","text":"<p>A common feature of template languages is to \"extend\" a base/parent template and specify placeholders. This can be achieved with a <code>base_layout</code> function:</p> components.py<pre><code>import datetime\n\nfrom htpy import body, div, h1, head, html, p, title, Node, Element\n\n\ndef base_page(*,\n    page_title: str | None = None,\n    extra_head: Node = None,\n    content: Node = None,\n    body_class: str | None = None,\n) -&gt; Element:\n    return html[\n        head[title[page_title], extra_head],\n        body(class_=body_class)[\n            content,\n            div(\"#footer\")[f\"Copyright {datetime.date.today().year} by Foo Inc.\"],\n        ],\n    ]\n\n\ndef index_page() -&gt; Element:\n    return base_page(\n        page_title=\"Welcome!\",\n        body_class=\"green\",\n        content=[\n            h1[\"Welcome to my site!\"],\n            p[\"Hello and welcome!\"],\n        ],\n    )\n\n\ndef about_page() -&gt; Element:\n    return base_page(\n        page_title=\"About us\",\n        content=[\n            h1[\"About us\"],\n            p[\"We love creating web sites!\"],\n        ],\n    )\n</code></pre>"},{"location":"common-patterns/#ui-components","title":"UI Components","text":"<p>Creating higher level wrappers for common UI components can be a good idea to reduce repetition.</p> <p>Wrapping Bootstrap Modal could be achieved with a function like this:</p> Creating wrapper for Bootstrap Modal<pre><code>from markupsafe import Markup\n\nfrom htpy import Element, Node, button, div, h5, span\n\n\ndef bootstrap_modal(*, title: str, body: Node = None, footer: Node = None) -&gt; Element:\n    return div(\".modal\", tabindex=\"-1\", role=\"dialog\")[\n        div(\".modal-dialog\", role=\"document\")[\n            div(\".modal-content\")[\n                div(\".modal-header\")[\n                    div(\".modal-title\")[\n                        h5(\".modal-title\")[title],\n                        button(\n                            \".close\",\n                            type=\"button\",\n                            data_dismiss=\"modal\",\n                            aria_label=\"Close\",\n                        )[span(aria_hidden=\"true\")[Markup(\"&amp;times;\")]],\n                    ]\n                ],\n                div(\".modal-body\")[body],\n                footer and div(\".modal-footer\")[footer],\n            ]\n        ]\n    ]\n</code></pre> <p>You would then use it like this:</p> <pre><code>from htpy import button, p\n\nprint(\n    bootstrap_modal(\n        title=\"Modal title\",\n        body=p[\"Modal body text goes here.\"],\n        footer=[\n            button(\".btn.btn-primary\", type=\"button\")[\"Save changes\"],\n            button(\".btn.btn-secondary\", type=\"button\")[\"Close\"],\n        ],\n    )\n)\n</code></pre>"},{"location":"django/","title":"Usage With Django","text":"<p>htpy is not tied to any specific web framework. Nonetheless, htpy works great when combined with Django. This page contains information and useful techniques on how to combine htpy and Django.</p>"},{"location":"django/#returning-a-htpy-response","title":"Returning a htpy Response","text":"<p>htpy elements can be passed directly to <code>HttpResponse</code>:</p> views.py<pre><code>from django.http import HttpResponse\nfrom htpy import html, body, div\n\ndef my_view(request):\n    return HttpResponse(html[body[div[\"Hi Django!\"]]])\n</code></pre>"},{"location":"django/#using-htpy-as-part-of-an-existing-django-template","title":"Using htpy as Part of an Existing Django Template","text":"<p>htpy elements are marked as \"safe\" and can be injected directly into Django templates. This can be useful if you want to start using htpy gradually in an existing template based Django project:</p> base.html<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;My Django Site&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        {{ content }}\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> views.py<pre><code>from django.shortcuts import render\n\nfrom htpy import h1\n\n\ndef index(request):\n    return render(request, \"base.html\", {\n        \"content\": h1[\"Welcome to my site!\"],\n    })\n</code></pre>"},{"location":"django/#render-a-django-form","title":"Render a Django Form","text":"<p>CSRF token, form widgets and errors can be directly used within htpy elements:</p> forms.py<pre><code>from django import forms\n\n\nclass MyForm(forms.Form):\n    name = forms.CharField()\n</code></pre> views.py<pre><code>from django.http import HttpRequest, HttpResponse\n\nfrom .components import my_form_page, my_form_success_page\nfrom .forms import MyForm\n\n\ndef my_form(request: HttpRequest) -&gt; HttpResponse:\n    form = MyForm(request.POST or None)\n    if form.is_valid():\n        return HttpResponse(my_form_success_page())\n\n    return HttpResponse(my_form_page(request, my_form=form))\n</code></pre> components.py<pre><code>from django.http import HttpRequest\nfrom django.template.backends.utils import csrf_input\n\nfrom htpy import Element, Node, body, button, form, h1, head, html, title\n\nfrom .forms import MyForm\n\n\ndef base_page(page_title: str, content: Node) -&gt; Element:\n    return html[\n        head[title[page_title]],\n        body[content],\n    ]\n\n\ndef my_form_page(request: HttpRequest, *, my_form: MyForm) -&gt; Element:\n    return base_page(\n        \"My form\",\n        form(method=\"post\")[\n            csrf_input(request),\n            my_form.errors,\n            my_form[\"name\"],\n            button[\"Submit!\"],\n        ],\n    )\n\n\ndef my_form_success_page() -&gt; Element:\n    return base_page(\n        \"Success!\",\n        h1[\"Success! The form was valid!\"],\n    )\n</code></pre>"},{"location":"django/#implement-custom-form-widgets-with-htpy","title":"Implement Custom Form Widgets With htpy","text":"<p>You can implement a custom form widget directly with htpy like this:</p> widgets.py<pre><code>from django.forms import widgets\n\nfrom htpy import sl_input\n\n\nclass ShoelaceInput(widgets.Widget):\n    \"\"\"\n    A form widget using Shoelace's &lt;sl-input&gt; element.\n    More info: https://shoelace.style/components/input\n    \"\"\"\n\n    def render(self, name, value, attrs=None, renderer=None):\n        return str(sl_input(attrs, name=name, value=value))\n</code></pre>"},{"location":"django/#the-htpy-template-backend","title":"The htpy Template Backend","text":"<p>htpy includes a custom template backend. It makes it possible to use htpy instead of Django templates in places where a template name is required.  This can be used with generic views or third party applications built to be used with Django templates.</p> <p>To enable the htpy template backend, add <code>htpy.django.HtpyTemplateBackend</code> to the <code>TEMPLATES</code> setting:</p> <pre><code>TEMPLATES = [\n    ... # Regular Django template configuration goes here\n    {\"BACKEND\": \"htpy.django.HtpyTemplateBackend\", \"NAME\": \"htpy\"}\n]\n</code></pre> <p>In places that expect template names, such as generic views, specify the import path as a string to a htpy component function:</p> pizza/views.py<pre><code>from django.views.generic import ListView\nfrom pizza.models import Pizza\n\n\nclass PizzaListView(ListView):\n    model = Pizza\n    template_name = \"pizza.components.pizza_list\"\n</code></pre> <p>In <code>pizza/components.py</code>, create a function that accepts two arguments: the template <code>Context</code> (a dictionary with the template variables) and a <code>HttpRequest</code>. It should return the htpy response:</p> pizza/components.py<pre><code>from htpy import li, ul\n\n\ndef pizza_list(context, request):\n    return ul[(li[pizza.name] for pizza in context[\"object_list\"])]\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-does-htpy-performance-compare-to-django-or-jinja-templates","title":"How does htpy performance compare to Django or Jinja templates?","text":"<p>The performance of HTML rendering is rarely the bottleneck in most web application. It is usually fast enough regardless of what method of constructing the HTML is being used.</p> <p>Given that it has been fast enough, there has not been much effort in optimizing htpy. It should be possible to significantly increase the effectiveness and we are open to contributions with benchmarks and speed improvements.</p> <p>That said, htpy is currently on par with Django templates when it comes to speed. Jinja2 is currently significantly faster than both Django templates and htpy. There is a small benchmark script in the repo that generates a table with 50 000 rows.</p>"},{"location":"faq/#can-htpy-generate-xmlxhtml","title":"Can htpy generate XML/XHTML?","text":"<p>No. Generating XML/XHTML is out of scope for this project. Use a XML library if you are looking to generate XML.</p> <p>htpy generates HTML, therefore \"void elements\" such as <code>&lt;br&gt;</code> does not include a trailing <code>/</code>.</p> <p>If you are looking to generate generic XML, <code>lxml.builder</code> could be a good alternative.</p>"},{"location":"faq/#does-not-generating-html-from-python-mean-mixing-concerns-between-presentation-and-business-logic","title":"Does not generating HTML from Python mean mixing concerns between presentation and business logic?","text":"<p>With a template language, putting HTML markup in separate files is enforced by design. Avoiding logic in the presentation layer is also mostly done by making the language very restrictive.</p> <p>It takes a little bit of planning and effort, but it is possible to have a nicely separated presentation layer that is free from logic. See Common patterns for more details on how you can structure your project.</p>"},{"location":"faq/#what-kind-of-black-magic-makes-from-htpy-import-whatever_element-work","title":"What kind of black magic makes <code>from htpy import whatever_element</code> work?","text":"<p>htpy uses the module level <code>__getattr__</code>. It was introduced in Python 3.7. It allows creating <code>Element</code> instances for any elements that are imported.</p>"},{"location":"faq/#why-does-htpy-not-provide-html-like-tag-syntax-with-angle-brackets-like-pyxl-and-jsx","title":"Why does htpy not provide HTML like tag syntax with angle brackets like pyxl and JSX?","text":"<p>htpy must be compatible with standard Python code formatters, editors and static type checkers. Unfortunately, it is not possible to support those workflows with a custom syntax without a massive effort to change those tools to support that syntax.</p>"},{"location":"html2htpy/","title":"Convert HTML to htpy Code","text":"<p>Maybe you already have a bunch of HTML, or templates that you would like to migrate to htpy. We got you covered. The utility command <code>html2htpy</code> ships with <code>htpy</code>, and can be used to transform existing html into Python code (htpy!).</p> <pre><code>$ html2htpy -h\nusage: html2htpy [-h] [-f {auto,ruff,black,none}] [-i {yes,h,no}] [--no-shorthand] [input]\n\npositional arguments:\n  input                 input HTML from file or stdin\n\noptions:\n  -h, --help            show this help message and exit\n  -f {auto,ruff,black,none}, --format {auto,ruff,black,none}\n                        Select one of the following formatting options: auto, ruff, black or none\n  -i {yes,h,no}, --imports {yes,h,no}\n                        Output mode for imports of found htpy elements\n  --no-shorthand        Use explicit `id` and `class_` kwargs instead of the shorthand #id.class syntax\n</code></pre> <p>Lets say you have an existing HTML file:</p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;htpy Recipes&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"header\"&gt;\n      &lt;h1&gt;Welcome to the cooking site&lt;/h1&gt;\n      &lt;p&gt;Your go-to place for delicious recipes!&lt;/p&gt;\n    &lt;/div&gt;\n\n    &lt;div id=\"recipe-of-the-day\" class=\"section\"&gt;\n      &lt;h2&gt;\n        Recipe of the Day: &lt;span class=\"highlight\"&gt;Spaghetti Carbonara&lt;/span&gt;\n      &lt;/h2&gt;\n      &lt;p&gt;This classic Italian dish is quick and easy to make.&lt;/p&gt;\n    &lt;/div&gt;\n\n    &lt;div id=\"footer\"&gt;\n      &lt;p&gt;&amp;copy; 2024 My Cooking Site. All rights reserved.&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now, if you run the command, it outputs the corresponding Python code (htpy).</p> <pre><code>$  html2htpy index.html\n</code></pre> <pre><code>from htpy import body, div, h1, h2, head, html, meta, p, span, title\n\nhtml(lang=\"en\")[\n    head[\n        meta(charset=\"UTF-8\"),\n        meta(name=\"viewport\", content=\"width=device-width, initial-scale=1.0\"),\n        title[\"htpy Recipes\"],\n    ],\n    body[\n        div(\"#header\")[\n            h1[\"Welcome to the cooking site\"], p[\"Your go-to place for delicious recipes!\"]\n        ],\n        div(\"#recipe-of-the-day.section\")[\n            h2[\"Recipe of the Day: \", span(\".highlight\")[\"Spaghetti Carbonara\"]],\n            p[\"This classic Italian dish is quick and easy to make.\"],\n        ],\n        div(\"#footer\")[p[\"\u00a9 2024 My Cooking Site. All rights reserved.\"]],\n    ],\n]\n</code></pre>"},{"location":"html2htpy/#piping-inputstdin-stream","title":"Piping Input/Stdin Stream","text":"<p>You can also pipe input to htpy, for example <code>cat demo.html | html2htpy</code>.</p> <p>This can be combined with other workflows in the way that you find most suitable. For example, you might pipe from your clipboard to htpy, and optionally direct the output to a file.</p>"},{"location":"html2htpy/#linux","title":"Linux","text":"<pre><code>xclip -o -selection clipboard | html2htpy &gt; output.py\n</code></pre>"},{"location":"html2htpy/#mac","title":"Mac","text":"<pre><code>pbpaste | html2htpy &gt; output.py\n</code></pre>"},{"location":"html2htpy/#windows","title":"Windows","text":"<pre><code>powershell Get-Clipboard | html2htpy &gt; output.py\n</code></pre>"},{"location":"html2htpy/#formatting-the-output","title":"Formatting the Output","text":"<p><code>html2htpy</code> can format the output Python code using <code>black</code> or <code>ruff</code>. Select the preferred formatter with the <code>-f</code>/<code>--format</code> flag. Options are <code>auto</code>, <code>ruff</code>, <code>black</code> and <code>none</code>.</p> <p>By default, the selection will be <code>auto</code>, formatting if it finds a formatter on path, prefering <code>ruff</code> if it's available. If no formatters are available on path, the output will not be formatted.</p>"},{"location":"html2htpy/#import-options","title":"Import Options","text":"<p>You have a couple of options regarding imports with the <code>-i</code>/<code>--imports</code> flag. Options are <code>yes</code> (default), <code>h</code>, <code>no</code>.</p>"},{"location":"html2htpy/#module-import-of-htpy-importsh","title":"Module import of htpy: <code>--imports=h</code>","text":"<p>Some people prefer to <code>import htpy as h</code> instead of importing individual elements from htpy. If this is you, you can use the <code>--imports=h</code> option to get corresponding output when using <code>html2htpy</code>.</p> $ html2htpy --imports=h example.html<pre><code>import htpy as h\n\nh.section(\"#main-section.hero.is-link\")[\n    h.p(\".subtitle.is-3.is-spaced\")[\"Welcome\"]\n]\n</code></pre>"},{"location":"html2htpy/#explicit-id-and-class-kwargs","title":"Explicit ID and Class Kwargs","text":"<p>If you prefer the explicit <code>id=\"id\", class_=\"class\"</code> kwargs syntax over the default htpy shorthand <code>#id.class</code> syntax, you can get it by passing the <code>--no-shorthand</code> flag.</p> example.html<pre><code>&lt;section id=\"main-section\" class=\"hero is-link\"&gt;\n  &lt;p class=\"subtitle is-3 is-spaced\"&gt;Welcome&lt;/p&gt;\n&lt;/section&gt;\n</code></pre>"},{"location":"html2htpy/#default-shorthand-yield-idclass","title":"Default Shorthand Yield <code>#id.class</code>","text":"$ html2htpy example.html<pre><code>from htpy import p, section\n\nsection(\"#main-section.hero.is-link\")[\n    p(\".subtitle.is-3.is-spaced\")[\"Welcome\"]\n]\n</code></pre>"},{"location":"html2htpy/#no-shorthand-yields-kwargs-id-class_","title":"No Shorthand Yields Kwargs <code>id</code>, <code>class_</code>","text":"$ html2htpy --no-shorthand example.html<pre><code>from htpy import p, section\n\nsection(id=\"main-section\", class_=\"hero is-link\")[\n    p(class_=\"subtitle is-3 is-spaced\")[\"Welcome\"]\n]\n</code></pre>"},{"location":"html2htpy/#template-interpolation-to-f-strings","title":"Template Interpolation to f-strings","text":"<p><code>html2htpy</code> will try to convert template variables to pythonic f-strings:</p> <p><code>template {{ variables }}</code> -&gt; <code>f\"template { variables }\"</code></p> <p>Note that other typical template syntax, such as loops <code>{% for x in y %}</code>, can not be transformed this way, so you will often have to clean up a bit after <code>html2htpy</code> is done with its thing.</p> <p>See the example below:</p> jinja.html<pre><code>&lt;body&gt;\n  &lt;h1&gt;{{ heading }}&lt;/h1&gt;\n  &lt;p&gt;Welcome to our cooking site, {{ user.name }}!&lt;/p&gt;\n\n  &lt;h2&gt;Recipe of the Day: {{ recipe.name }}&lt;/h2&gt;\n  &lt;p&gt;{{ recipe.description }}&lt;/p&gt;\n\n  &lt;h3&gt;Instructions:&lt;/h3&gt;\n  &lt;ol&gt;\n    {% for step in recipe.steps %}\n    &lt;li&gt;{{ step }}&lt;/li&gt;\n    {% endfor %}\n  &lt;/ol&gt;\n&lt;/body&gt;\n</code></pre> $ html2htpy jinja.html<pre><code>from htpy import body, h1, h2, h3, li, ol, p\n\nbody[\n    h1[f\"{ heading }\"],\n    p[f\"Welcome to our cooking site, { user.name }!\"],\n    h2[f\"Recipe of the Day: { recipe.name }\"],\n    p[f\"{ recipe.description }\"],\n    h3[\"Instructions:\"],\n    ol[\n        \"\"\"        {% for step in recipe.steps %}        \"\"\",\n        li[f\"{ step }\"],\n        \"\"\"        {% endfor %}    \"\"\",\n    ],\n]\n</code></pre>"},{"location":"references/","title":"References","text":""},{"location":"references/#related-projects","title":"Related projects","text":"<ul> <li>pyxy - Write HTML tags directly in Python (like JSX). Uses htpy to generate markup. A modern take on pyxl.</li> </ul>"},{"location":"references/#projects-that-use-htpy","title":"Projects That Use htpy","text":"<ul> <li>voterbowl.org - College students win prizes by checking if they are registered to vote: Github repository.</li> </ul>"},{"location":"references/#prior-implementations-of-html-in-python","title":"Prior implementations of HTML in Python","text":"<p>htpy was heavily inspired by many other libraries that came before it.</p> <ul> <li>JSX/React - Made writing HTML in a programming language popular.</li> <li>pyxl, pyxl3, pyxl4 - Write HTML in Python with JSX-like syntax. Not actively maintained.</li> <li>htbuilder - Very similar to htpy but does not currently support automatic escaping.</li> <li>nevow.stan - Probably the earliest use of <code>[]</code> syntax for specifying children. Not actively maintained.</li> <li>breve - Another early implementation of HTML in Python, Using getattr <code>[]</code> syntax for children. Not actively maintained.</li> <li>hyperscript - JavaScript library that also uses CSS selector-like syntax for specifying id and classes.</li> <li>hyperpython - A Python interpretation of hyperscript. Not actively maintained.</li> <li>h by Adam Johnson - Similar to htpy, uses call syntax (<code>()</code>) for attributes and getitem (<code>[]</code>) for children.</li> <li>lxml.builder - lxml's <code>E</code> allows creating XML/XHTML documents from Python.</li> </ul>"},{"location":"references/#articles-about-html-generation-without-templates","title":"Articles About HTML Generation Without Templates","text":"<ul> <li>Jeff Atwood - You're Doing It Wrong - Stack Overflow co-founder Jeff Atwood</li> <li>Tavis Rudd - Throw out your templates - Tavis Rudd, creator of Python template language \"Cheetah\" argues for creating HTML without templates.</li> <li>David Ford - 80% of my coding is doing this (or why templates are dead) - Discusses various techniques for rendering HTML.</li> </ul>"},{"location":"starlette/","title":"Usage with Starlette","text":"<p>htpy can be used with Starlette to generate HTML. Since FastAPI is built upon Starlette, htpy can also be used with FastAPI.</p> <p>To return HTML contents, pass a htpy element to Starlette's <code>HTMLResponse</code>:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse\nfrom starlette.routing import Route\n\nfrom htpy import h1\n\n\nasync def index(request: Request) -&gt; HTMLResponse:\n    return HTMLResponse(h1[\"Hi Starlette!\"])\n\n\napp = Starlette(routes=[Route(\"/\", index)])\n</code></pre>"},{"location":"static-typing/","title":"Static Typing","text":"<p>htpy was designed to be used with static typing. Since you define all your own data/components with regular Python, a static type checker like mypy will catch errors like this:</p> <pre><code>class User:\n    def __init__(self, name: str):\n        self.name = name\n\n\ndef greeting(user: User) -&gt; Element:\n    return h1[f\"Hi {user.first_name.capitalize()}!]\n#                        ^^^^^^^^^^\n# mypy: error: \"User\" has no attribute \"first_name\"  [attr-defined]\n</code></pre>"},{"location":"static-typing/#autocompletion-of-html-elements","title":"Autocompletion of HTML Elements","text":"<p>htpy ships with type annotations for all HTML elements. If your editor supports it, it will show you useful auto completions:</p> <p></p>"},{"location":"static-typing/#element-and-voidelement-classes","title":"<code>Element</code> and <code>VoidElement</code> Classes","text":"<p>The base types/classes in htpy are <code>Element</code> and <code>VoidElement</code>. <code>Element</code> are all regular HTML elements that can have children such as <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code> and <code>&lt;table&gt;</code>. <code>VoidElement</code> are HTML void element which cannot have children such as <code>&lt;img&gt;</code>, <code>&lt;input&gt;</code> and <code>&lt;br&gt;</code>.</p> <p>Use <code>Element</code> as the return type when you want to always return an element.</p> <pre><code>from typing import Literal\n\nfrom htpy import Element, span\n\n\ndef bootstrap_badge(\n    text: str,\n    style: Literal[\"primary\", \"success\", \"danger\"] = \"primary\",\n) -&gt; Element:\n    return span(f\".badge.text-bg-{style}\")[text]\n</code></pre>"},{"location":"static-typing/#node","title":"Node","text":"<p><code>Node</code> is a type alias for all possible objects that can be used as a child node. See the source for the exact definition that defines all kinds of nodes that can be children of an element. This is a wider type than <code>Element</code> since child nodes can be str, markup, None, iterables or callables.</p> <p>Use <code>Node</code> when you want to create a wrapper function to be flexible with what you accept. This function will accept both a str or some other element to be passed as <code>contents</code>:</p> <pre><code>from htpy import Element, Node, div\n\ndef bootstrap_alert(contents: Node) -&gt; Element:\n    return div(\".alert\", role=\"alert\")[contents]\n</code></pre>"},{"location":"streaming/","title":"Streaming of Contents","text":"<p>Internally, htpy is built with generators. Most of the time, you would render the full page with <code>str()</code>, but htpy can also incrementally generate pages which can then be streamed to the browser. If your page uses a database or other services to retrieve data, you can sending the first part of the page to the client while the page is being generated.</p> <p>Note</p> <p>Streaming requires a bit of discipline and care to get right. You need to ensure to avoid doing too much work up front and use lazy constructs such as generators and callables. Most of the time, rendering the page without streaming will be the easiest way to get going. Streaming can give you improved user experience from faster pages/rendering.</p> <p>This video shows what it looks like in the browser to generate a HTML table with Django StreamingHttpResponse (source code):</p> <p>This example simulates a (very) slow fetch of data and shows the power of streaming: The browser loads CSS and gradually shows the contents. By loading CSS files in the <code>&lt;head&gt;</code> tag before dynamic content, the browser can start working on loading the CSS and styling the page while the server keeps generating the rest of the page.</p>"},{"location":"streaming/#using-generators-and-callables-as-children","title":"Using Generators and Callables as Children","text":"<p>Django's querysets are lazily evaluated. They will not execute a database query before their value is actually needed.</p> <p>This example shows how this property of Django querysets can be used to create a page that streams objects:</p> <pre><code>from django.http import StreamingHttpResponse\nfrom htpy import ul, li\n\nfrom myapp.models import Article\n\ndef article_list(request):\n    return StreamingHttpResponse(ul[\n        (li[article.title] for article in Article.objects.all())\n    ])\n</code></pre>"},{"location":"streaming/#using-callables-to-delay-evalutation","title":"Using Callables to Delay Evalutation","text":"<p>Pass a callable that does not accept any arguements as child to delay the evaluation.</p> <p>This example shows how the page starts rendering and outputs the <code>&lt;h1&gt;</code> tag and then calls <code>calculate_magic_number</code>.</p> <pre><code>import time\nfrom htpy import div, h1\n\ndef calculate_magic_number() -&gt; str:\n    time.sleep(1)\n    print(\"  (running the complex calculation...)\")\n    return \"42\"\n\nelement = div[\n    h1[\"Welcome to my page\"],\n    \"The magic number is \",\n    calculate_magic_number,\n]\n\nfor chunk in element:\n    print(chunk)\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;\n&lt;h1&gt;\nWelcome to my page\n&lt;/h1&gt;\nThe magic number is\n42    # &lt;-- Appears after 3 seconds\n&lt;/div&gt;\n</code></pre> <p>You may use <code>lambda</code> to create a function without arguments to make a an expression lazy:</p> <pre><code>from htpy import div, h1\n\n\ndef fib(n: int) -&gt; int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\nprint(\n    div[\n        h1[\"Fibonacci!\"],\n        \"fib(20)=\",\n        lambda: str(fib(20)),\n    ]\n)\n# output: &lt;div&gt;&lt;h1&gt;Fibonacci!&lt;/h1&gt;fib(12)=6765&lt;/div&gt;\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Elements are imported directly from the <code>htpy</code> module as their name. HTML attributes are specified by parenthesis (<code>()</code> / \"call\"). Children are specified using square brackets (<code>[]</code> / \"getitem\").</p> <pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(id=\"hi\")[\"Hello!\"])\n&lt;div id=\"hi\"&gt;Hello!&lt;/div&gt;\n</code></pre>"},{"location":"usage/#elements","title":"Elements","text":"<p>Children can be strings, markup, other elements or lists/iterators.</p> <p>Elements can be arbitrarily nested:</p> Nested elements<pre><code>&gt;&gt;&gt; from htpy import article, section, p\n&gt;&gt;&gt; print(section[article[p[\"Lorem ipsum\"]]])\n&lt;section&gt;&lt;article&gt;&lt;p&gt;Lorem ipsum&lt;/p&gt;&lt;/article&gt;&lt;/section&gt;\n</code></pre>"},{"location":"usage/#textstrings","title":"Text/Strings","text":"<p>It is possible to pass a string directly:</p> Using a string as children<pre><code>&gt;&gt;&gt; from htpy import h1\n&gt;&gt;&gt; print(h1[\"Welcome to my site!\"])\n&lt;h1&gt;Welcome to my site!&lt;/h1&gt;\n</code></pre> <p>Strings are automatically escaped to avoid XSS vulnerabilities. It is convenient and safe to directly insert variable data via f-strings:</p> <pre><code>&gt;&gt;&gt; from htpy import h1\n&gt;&gt;&gt; user_supplied_name = \"bobby &lt;/h1&gt;\"\n&gt;&gt;&gt; print(h1[f\"hello {user_supplied_name}\"])\n&lt;h1&gt;hello bobby &amp;lt;/h1&amp;gt;&lt;/h1&gt;\n</code></pre>"},{"location":"usage/#conditional-rendering","title":"Conditional Rendering","text":"<p><code>True</code>, <code>False</code> and <code>None</code> will not render anything. Python's <code>and</code> and <code>or</code> operators will short-circuit. You can use this to conditionally render content with inline <code>and</code> and <code>or</code>.</p> Conditional rendering with a value that may be None<pre><code>&gt;&gt;&gt; from htpy import div, b\n&gt;&gt;&gt; error = None\n\n&gt;&gt;&gt; # No &lt;b&gt; tag will be rendered since error is None\n&gt;&gt;&gt; print(div[error and b[error]])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; error = 'Enter a valid email address.'\n&gt;&gt;&gt; print(div[has_error and b[error_message]])\n&lt;div&gt;&lt;b&gt;Enter a valid email address.&lt;/b&gt;&lt;/div&gt;\n\n# Inline if/else can also be used:\n&gt;&gt;&gt; print(div[b[error] if error else None])\n&lt;div&gt;&lt;b&gt;Enter a valid email address.&lt;/b&gt;&lt;/div&gt;\n</code></pre> Conditional rendering based on a bool variable<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; is_happy = True\n&gt;&gt;&gt; print(div[is_happy and \"\ud83d\ude04\"])\n&lt;div&gt;\ud83d\ude04&lt;/div&gt;\n\n&gt;&gt;&gt; is_sad = False\n&gt;&gt;&gt; print(div[is_sad and \"\ud83d\ude14\"])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; is_allowed = True\n&gt;&gt;&gt; print(div[is_allowed or \"Access denied!\"])\n&lt;div&gt;&lt;/div&gt;\n\n&gt;&gt;&gt; is_allowed = False\n&gt;&gt;&gt; print(div[is_allowed or \"Access denied!\"])\n&lt;div&gt;Access denied&lt;/div&gt;\n</code></pre>"},{"location":"usage/#loops-iterating-over-children","title":"Loops / Iterating Over Children","text":"<p>You can pass a list, tuple or generator to generate multiple children:</p> Iterate over a generator<pre><code>&gt;&gt;&gt; from htpy import ul, li\n&gt;&gt;&gt; print(ul[(li[letter] for letter in \"abc\")])\n&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;\n</code></pre> <p>Note</p> <p>The generator will be lazily evaluated when rendering the element, not directly when the element is constructed. See Streaming for more information.</p> <p>A <code>list</code> can be used similar to a JSX fragment:</p> Render a list of child elements<pre><code>&gt;&gt;&gt; from htpy import div, img\n&gt;&gt;&gt; my_images = [img(src=\"a.jpg\"), img(src=\"b.jpg\")]\n&gt;&gt;&gt; print(div[my_images])\n&lt;div&gt;&lt;img src=\"a.jpg\"&gt;&lt;img src=\"b.jpg\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#custom-elements-web-components","title":"Custom Elements / Web Components","text":"<p>Custom elements / web components are HTML elements that contain at least one dash (<code>-</code>). Since <code>-</code> cannot be used in Python identifiers, use underscore (<code>_</code>) instead:</p> Using custom elements<pre><code>&gt;&gt;&gt; from htpy import my_custom_element\n&gt;&gt;&gt; print(my_custom_element['hi!'])\n&lt;my-custom-element&gt;hi!&lt;/my-custom-element&gt;\n</code></pre>"},{"location":"usage/#injecting-markup","title":"Injecting Markup","text":"<p>If you have HTML markup that you want to insert without further escaping, wrap it in <code>Markup</code> from the markupsafe library. markupsafe is a dependency of htpy and is automatically installed:</p> Injecting markup<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; print(div[Markup(\"&lt;foo&gt;&lt;/foo&gt;\")])\n&lt;div&gt;&lt;foo&gt;&lt;/foo&gt;&lt;/div&gt;\n</code></pre> <p>If you are generating Markdown and want to insert it into an element,  use <code>Markup</code> to mark it as safe:</p> Injecting generated markdown<pre><code>&gt;&gt;&gt; from markdown import markdown\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div[Markup(markdown('# Hi'))])\n&lt;div&gt;&lt;h1&gt;Hi&lt;/h1&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#html-doctype","title":"HTML Doctype","text":"<p>The HTML doctype is automatically prepended to the <code>&lt;html&gt;</code> tag:</p> <pre><code>&gt;&gt;&gt; from htpy import html\n&gt;&gt;&gt; print(html)\n&lt;!doctype html&gt;&lt;html&gt;&lt;/html&gt;\n</code></pre>"},{"location":"usage/#html-comments","title":"HTML Comments","text":"<p>Since the Python code is the source of the HTML generation, to add a comment to the code, most of the time regular Python comments (<code>#</code>) are used.</p> <p>If you want to emit HTML comments that will be visible in the browser, use the <code>comment</code> function:</p> <pre><code>&gt;&gt;&gt; from htpy import div, comment\n&gt;&gt;&gt; print(div[comment(\"This is a HTML comment, visible in the browser!\")])\n&lt;div&gt;&lt;!-- This is a HTML comment, visible in the browser! --&gt;&lt;/div&gt;\n</code></pre> <p>It is safe to pass arbitrary text to the comment function. Double dashes (<code>--</code>) will be removed to avoid being able to break out of the comment.</p> <p>If you need full control over the exact rendering of the comment, you can create comments or arbitrary text by injecting your own markup. See the Injecting Markup section above for details.</p>"},{"location":"usage/#attributes","title":"Attributes","text":"<p>HTML attributes are defined by calling the element. They can be specified in a couple of different ways.</p>"},{"location":"usage/#elements-without-attributes","title":"Elements Without Attributes","text":"<p>Some elements do not have attributes, they can be specified by just the element itself:</p> <pre><code>&gt;&gt;&gt; from htpy import hr\n&gt;&gt;&gt; print(hr)\n&lt;hr&gt;\n</code></pre>"},{"location":"usage/#keyword-arguments","title":"Keyword Arguments","text":"<p>Attributes can be specified via keyword arguments:</p> <pre><code>&gt;&gt;&gt; from htpy import img\n&gt;&gt;&gt; print(img(src=\"picture.jpg\"))\n&lt;img src=\"picture.jpg\"&gt;\n</code></pre> <p>In Python, <code>class</code> and <code>for</code> cannot be used as keyword arguments. Instead, they can be specified as <code>class_</code> or <code>for_</code> when using keyword arguments:</p> <pre><code>&gt;&gt;&gt; from htpy import label\n&gt;&gt;&gt; print(label(for_=\"myfield\"))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre> <p>Attributes that contain dashes <code>-</code> can be specified using underscores:</p> <pre><code>&gt;&gt;&gt; from htpy import form\n&gt;&gt;&gt; print(form(hx_post=\"/foo\"))\n&lt;form hx-post=\"/foo\"&gt;&lt;/form&gt;\n</code></pre>"},{"location":"usage/#idclass-shorthand","title":"Id/Class Shorthand","text":"<p>Defining <code>id</code> and <code>class</code> attributes is common when writing HTML. A string shorthand that looks like a CSS selector can be used to quickly define id and classes:</p> Define id<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(\"#myid\"))\n&lt;div id=\"myid\"&gt;&lt;/div&gt;\n</code></pre> Define multiple classes<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(\".foo.bar\"))\n&lt;div class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre> Combining both id and classes<pre><code>&gt;&gt;&gt; from htpy import div\n&gt;&gt;&gt; print(div(\"#myid.foo.bar\"))\n&lt;div id=\"myid\" class=\"foo bar\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"usage/#attributes-as-dict","title":"Attributes as Dict","text":"<p>Attributes can also be specified as a <code>dict</code>. This is useful when using attributes that are reserved Python keywords (like <code>for</code> or <code>class</code>), when the attribute name contains a dash (<code>-</code>) or when you want to define attributes dynamically.</p> Using Alpine.js with @-syntax (shorthand for x-on)<pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; print(button({\"@click.shift\": \"addToSelection()\"}))\n&lt;button @click.shift=\"addToSelection()\"&gt;&lt;/button&gt;\n</code></pre> Using an attribute with a reserved keyword<pre><code>&gt;&gt;&gt; from htpy import label\n&gt;&gt;&gt; print(label({\"for\": \"myfield\"}))\n&lt;label for=\"myfield\"&gt;&lt;/label&gt;\n</code></pre>"},{"location":"usage/#booleanempty-attributes","title":"Boolean/Empty Attributes","text":"<p>In HTML, boolean attributes such as <code>disabled</code> are considered \"true\" when they exist. Specifying an attribute as <code>True</code> will make it appear (without a value). <code>False</code> will make it hidden. This is useful and brings the semantics of <code>bool</code> to HTML.</p> True bool attribute<pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; print(button(disabled=True))\n&lt;button disabled&gt;&lt;/button&gt;\n</code></pre> False bool attribute<pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; print(button(disabled=False))\n&lt;button&gt;&lt;/button&gt;\n</code></pre>"},{"location":"usage/#conditionally-mixing-css-classes","title":"Conditionally Mixing CSS Classes","text":"<p>To make it easier to mix CSS classes, the <code>class</code> attribute accepts a list of class names or a dict. Falsey values will be ignored.</p> <pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; is_primary = True\n&gt;&gt;&gt; print(button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn btn-primary\"&gt;&lt;/button&gt;\n&gt;&gt;&gt; is_primary = False\n&gt;&gt;&gt; print(button(class_=[\"btn\", {\"btn-primary\": is_primary}]))\n&lt;button class=\"btn\"&gt;&lt;/button&gt;\n&gt;&gt;&gt;\n</code></pre>"},{"location":"usage/#combining-modes","title":"Combining Modes","text":"<p>Attributes via id/class shorthand, keyword arguments and dictionary can be combined:</p> Specifying attribute via multiple arguments<pre><code>&gt;&gt;&gt; from htpy import label\n&gt;&gt;&gt; print(label(\"#myid.foo.bar\", {'for': \"somefield\"}, name=\"myname\",))\n&lt;label id=\"myid\" class=\"foo bar\" for=\"somefield\" name=\"myname\"&gt;&lt;/label&gt;\n</code></pre>"},{"location":"usage/#escaping-of-attributes","title":"Escaping of Attributes","text":"<p>Attributes are always escaped. This makes it possible to pass arbitrary HTML fragments or scripts as attributes. The output may look a bit obfuscated since all unsafe characters are escaped but the browser will interpret it correctly:</p> <pre><code>&gt;&gt;&gt; from htpy import button\n&gt;&gt;&gt; print(button(id=\"example\", onclick=\"let name = 'andreas'; alert('hi' + name);\")[\"Say hi\"])\n&lt;button onclick=\"let name = &amp;#39;andreas&amp;#39;; alert(&amp;#39;hi&amp;#39; + name);\"&gt;Say hi&lt;/button&gt;\n</code></pre> <p>In the browser, the parsed attribute as returned by <code>document.getElementById(\"example\").getAttribute(\"onclick\")</code> will be the original string <code>let name = 'andreas'; alert('hi' + name);</code>.</p> <p>Escaping will happen whether or not the value is wrapped in <code>markupsafe.Markup</code> or not. This may seem confusing at first but is useful when embedding HTML snippets as attributes:</p> Escaping of Markup<pre><code>&gt;&gt;&gt; from htpy import ul\n&gt;&gt;&gt; from markupsafe import Markup\n&gt;&gt;&gt; # This markup may come from another library/template engine\n&gt;&gt;&gt; some_markup = Markup(\"\"\"&lt;li class=\"bar\"&gt;&lt;/li&gt;\"\"\")\n&gt;&gt;&gt; print(ul(data_li_template=some_markup))\n&lt;ul data-li-template=\"&amp;lt;li class=&amp;#34;bar&amp;#34;&amp;gt;&amp;lt;/li&amp;gt;\"&gt;&lt;/ul&gt;\n</code></pre>"},{"location":"usage/#render-elements-without-a-parent-orphans","title":"Render elements without a parent (orphans)","text":"<p>In some cases such as returning partial content it is useful to render elements without a parent element. This is useful in HTMX partial responses.</p> <p>You may use <code>render_node</code> to achieve this:</p> Render elements without a parent<pre><code>&gt;&gt;&gt; from htpy import render_node, tr\n&gt;&gt;&gt; print(render_node([tr[\"a\"], tr[\"b\"]]))\n&lt;tr&gt;a&lt;/tr&gt;&lt;tr&gt;b&lt;/tr&gt;\n</code></pre> <p><code>render_node()</code> accepts all kinds of <code>Node</code> objects. You may use it to render anything that would normally be a children of another element.</p> <p>Best practice: Only use render_node() to render non-Elements</p> <p>You can render regular elements by using <code>str()</code>, e.g. <code>str(p[\"hi\"])</code>. While <code>render_node()</code> would give the same result, it is more straightforward and better practice to just use <code>str()</code> when rendering a regular element. Only use <code>render_node()</code> when you do not have a parent element.</p>"},{"location":"usage/#iterating-of-the-output","title":"Iterating of the Output","text":"<p>Iterating over a htpy element will yield the resulting contents in chunks as they are rendered:</p> <pre><code>&gt;&gt;&gt; from htpy import ul, li\n&gt;&gt;&gt; for chunk in ul[li[\"a\"], li[\"b\"]]:\n...     print(f\"got a chunk: {chunk!r}\")\n...\ngot a chunk: '&lt;ul&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'a'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'b'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;/ul&gt;'\n</code></pre> <p>Just like render_node(), there is <code>iter_node()</code> that can be used when you need to iterate over a list of elements without a parent:</p> <pre><code>&gt;&gt;&gt; from htpy import li, iter_node\n&gt;&gt;&gt; for chunk in iter_node([li[\"a\"], li[\"b\"]]):\n...     print(f\"got a chunk: {chunk!r}\")\n...\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'a'\ngot a chunk: '&lt;/li&gt;'\ngot a chunk: '&lt;li&gt;'\ngot a chunk: 'b'\ngot a chunk: '&lt;/li&gt;'\n</code></pre>"},{"location":"usage/#passing-data-with-context","title":"Passing Data with Context","text":"<p>Usually, you pass data via regular function calls and arguments via your components. Contexts can be used to avoid having to pass the data manually between components. Contexts in htpy is conceptually similar to contexts in React.</p> <p>Using contexts in htpy involves:</p> <ul> <li>Creating a context object with <code>my_context = Context(name[, *, default])</code> to define the type and optional default value of a context variable.</li> <li>Using <code>my_context.provider(value, lambda: children)</code> to set the value of a context variable for a subtree.</li> <li>Adding the <code>@my_context.consumer</code> decorator to a component that requires the context value. The decorator will add the context value as the first argument to the decorated function:</li> </ul> <p>The <code>Context</code> class is a generic and fully supports static type checking.</p> <p>The values are passed as part of the tree used to render components without using global state. It is safe to use contexts for lazy constructs such as callables and generators.</p> <p>A context value can be passed arbitrarily deep between components. It is possible to nest multiple context provider and different values can be used in different subtrees.</p> <p>A single component can consume as many contexts as possible by using multiple decorators:</p> <pre><code>@context_b.consumer\n@context_a.consumer\ndef my_component(a, b):\n    ...\n</code></pre>"},{"location":"usage/#example","title":"Example","text":"<p>This example shows how context can be used to pass data between components:</p> <ul> <li><code>theme_context: Context[Theme] = Context(\"theme\", default=\"light\")</code> creates a context object that can later be used to define/retrieve the value. In this case, <code>\"light\"</code> acts as the default value if no other value is provided.</li> <li><code>theme_context.provider(value, lambda: subtree)</code> defines the value of the <code>theme_context</code> for the subtree. In this case the value is set to <code>\"dark\"</code> which overrides the default value.</li> <li>The <code>sidebar</code> component uses the <code>@theme_context.consumer</code> decorator. This will make htpy pass the current context value as the first argument to the component function.</li> <li>In this example, a <code>Theme</code> type is used to ensure that the correct types are used when providing the value as well as when it is consumed.</li> </ul> <pre><code>from typing import Literal\n\nfrom htpy import Context, Node, div, h1\n\nTheme = Literal[\"light\", \"dark\"]\n\ntheme_context: Context[Theme] = Context(\"theme\", default=\"light\")\n\n\ndef my_page() -&gt; Node:\n    return theme_context.provider(\n        \"dark\",\n        lambda: div[\n            h1[\"Hello!\"],\n            sidebar(\"The Sidebar!\"),\n        ],\n    )\n\n\n@theme_context.consumer\ndef sidebar(theme: Theme, title: str) -&gt; Node:\n    return div(class_=f\"theme-{theme}\")[title]\n\n\nprint(my_page())\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;div class=\"theme-dark\"&gt;The Sidebar!&lt;/div&gt;&lt;/div&gt;\n</code></pre>"}]}